/**
 * ZKx402 Express Middleware
 *
 * Adds ZK-Fair-Pricing proofs to x402 payment challenges
 */

import type { Request, Response, NextFunction } from "express";
import { ZKProver } from "./prover.js";
import type { PublicTariff, PricingRequest } from "./types.js";

export interface ZKx402Config {
  /** Public pricing tariff */
  tariff: PublicTariff;
  /** zkEngine prover instance */
  prover?: ZKProver;
  /** Function to compute request metadata (tokens, tier) */
  computeMetadata: (req: Request) => PricingRequest;
  /** x402 payment facilitator config */
  facilitator: {
    chain: string; // e.g., "base-sepolia"
    asset: string; // e.g., "usdc"
  };
}

/**
 * Creates an x402 middleware that adds ZK pricing proofs
 *
 * Usage:
 * ```ts
 * app.get('/api/llm/generate',
 *   zkx402Middleware({
 *     tariff: MY_TARIFF,
 *     computeMetadata: (req) => ({
 *       tokens: estimateTokens(req.body.prompt),
 *       tier: req.user?.tier || 0,
 *     }),
 *     facilitator: { chain: 'base-sepolia', asset: 'usdc' }
 *   }),
 *   async (req, res) => {
 *     // This only runs if payment is valid
 *     res.json({ result: '...' });
 *   }
 * );
 * ```
 */
export function zkx402Middleware(config: ZKx402Config) {
  const prover = config.prover || new ZKProver();

  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      // Check if payment header exists
      const paymentHeader = req.headers["x-payment"] as string | undefined;

      if (!paymentHeader) {
        // No payment provided -> Send 402 challenge with ZK proof
        const metadata = config.computeMetadata(req);

        // Generate ZK proof of fair pricing
        const proof = await prover.generatePricingProof(
          metadata,
          config.tariff
        );

        // Format x402 payment specification
        const acceptPayment = `${config.facilitator.chain}:${config.facilitator.asset}:${proof.price}`;

        // Send 402 with pricing proof
        res.status(402);
        res.setHeader("X-Accept-Payment", acceptPayment);
        res.setHeader(
          "X-Pricing-Proof",
          JSON.stringify({
            proof: proof.proof,
            type: proof.proofType,
            price: proof.price.toString(),
            tariff: config.tariff,
          })
        );

        return res.json({
          error: "Payment Required",
          details: {
            price: proof.price.toString(),
            chain: config.facilitator.chain,
            asset: config.facilitator.asset,
            zkProof: {
              type: "fair-pricing",
              verified: true,
              message:
                "This price has been cryptographically proven to match the public tariff",
            },
          },
        });
      }

      // Payment exists -> Verify it
      // TODO: Call facilitator to verify payment
      // For now, we trust the payment header

      // Attach payment info to request for downstream handlers
      (req as any).zkx402 = {
        paid: true,
        payment: paymentHeader,
      };

      next();
    } catch (error) {
      console.error("ZKx402 middleware error:", error);
      res.status(500).json({
        error: "Internal server error during ZK proof generation",
      });
    }
  };
}

/**
 * Helper to verify a pricing proof from a client
 */
export async function verifyPricingProof(
  proofHeader: string
): Promise<boolean> {
  try {
    const data = JSON.parse(proofHeader);
    const prover = new ZKProver();

    // TODO: Implement full verification
    // For MVP, we trust proofs generated by our service
    return true;
  } catch {
    return false;
  }
}
